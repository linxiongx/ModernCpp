<h1 align = "center">多线程数据通信：future</h1>

# 一、std::async 

+ ### 定义

  #### std::async 是C++11标准库中的一个函数模板，用于异步执行可调用对象，返回一个 std::future 对象来获取异步操作的结果。 

  

+ ### 参数转发

  ##### std::async 的参数转发与 std::thread 相同<font color='gray'>~（请参考《线程管理》篇）~</font>

  ```c++
  std::async(threadFunc, 100); //传普通参数
  std::async(threadFunc, std::ref(value)) //传引用
  std::async(&X::doWork, &myX, 100) //类成员函数
  ```

  

+ ### 启动策略

  ##### std::async 有一重载函数，增加了启动策略参数

  + ##### std::launch::deferred                                                      延迟同步执行：表明函数调用延迟到 std::future::wait() 或 std::future::get() 函数调用时才执行

  + ##### std::launch::async                                                          立即异步执行：表明函数必须在独立线程上执行

  + ##### std::launch::deferred | std::launch::async           [默认] 表明由编译器决定是立即异步执行还是延迟同步执行

    

+ ### 返回类型

  ##### std::async 返回的是 std::future 对象

  

+ ### std::async  与  std::thread  的比较

  + #### std::async 由线程库自动管理，std::thread 需要手动管理(手动调用 join 或 detach )
  
  + #### std::async 可以延迟执行，std::thread 创建时立即执行
  
  + #### std::async 可以异步执行也可以同步执行，std::thread 只能异步执行
  
  + #### std::async 可以获取返回值，std::thread 需要借助共享变量等方式
  
  + #### std::async 可以在创建线程捕获新线程的异常，std::thread 只能在新线程中捕获异常
  
  + #### std::async 可能使用线程池，创建开销更低
  
  

## 二、 std::future

##### std::async 返回一个 std::future 对象，这个对象持有线程的返回值。当需要这个值时，只需要调用这个对象的 get() 成员函数，就会阻塞线程直到 futrue 为就绪为止，并返回计算结果。

##### std::future 是一个函数模板，其模版类型参数就是与其关联的函数的返回值。

```c++
int func(int& value)
{
	value = 30;
	return 100;
}

int value = 20;
std::future<int> futureObj = std::async(std::launch::deferred, func, std::ref(value)); //延迟到 get() 函数调用时，在当前线程执行
std::future<int> futureObj = std::async(std::launch::async, func, std::ref(value)); // 在新线程执行

int result = futureObj.get(); // 获取线程返回值(100)
```



## 三、异常处理

##### std::future 提供了异步异常传播机制，异步任务中抛出的异常会被捕获并保存，在调用 get() 时重新抛出

```c++
int func()
{
	throw std::runtime_error("异步任务中的错误");
	return 100;
}

std::future<int> futureObj = std::async(std::launch::async, func); // 在新线程执行
try
{
	int result = futureObj.get(); 
}
catch (const std::runtime_error& e)
{
    cout << "捕获到异常：" << e.what() << endl;
}

```



## 四、std::futrue 具有只移属性

##### std::futrue 具有只移属性，第一次调用 get() 后，资源被移走，不可以再次调用 get()，否则会抛出异常

```c++
std::future<int> futureObj = std::async(std::launch::async, func); // 在新线程执行
std::future<int> futureObjCopy = futureObj; // error! std::future 不可复制

int result = futureObj.get(); // 第一次调用 get(), 资源被转移到 result
try
{
	int result = futureObj.get();  // 第二次调用 get()，会抛出异常
}
catch (const std::exception& e)
{
    cout << "捕获到异常：" << e.what() << endl;
}
```



## 五、std::shared_future

+ ##### std::future 不是线程安全的，多个线程访问同一个 std::future 时，需要互斥量保护。且 get() 只能调用一次。

  ```c++
  void futureFunc(std::future<int>& fu)
  {
  	try
  	{
  		cout << "futureFunc = " << fu.get() << endl;
  	}
  	catch (...)
  	{
  		cout << "futureFunc 捕获到 std::future::get 异常" << endl;
  	}
  }
  
  std::future<int> f = std::async(std::launch::async, threadFunc);
  
  auto t1 = thread(futureFunc, std::ref(f)); //优先执行的可以正常调用 get();
  auto t2 = thread(futureFunc, std::ref(f)); //后执行的再次调用 get() 会发生异常;
  
  t1.join();
  t2.join();
  ```

  

+ ##### std::shared_future 的 get() 可以多次调用

  ```c++
  std::shared_future<int> futureObj = std::async(std::launch::async, func); // 在新线程执行
  int result = futureObj.get(); // ok
  int result = futureObj.get(); // ok
  ```

  

+ ##### std::shared_future 的副本是线程安全的

  ```c++
  void futureFunc(std::shared_future<int> fu)
  {
  	try
  	{
  		cout << "futureFunc = " << fu.get() << endl;
  	}
  	catch (...)
  	{
  		cout << "futureFunc 捕获到 std::future::get 异常" << endl;
  	}
  }
  
  std::shared_future<int> f = std::async(std::launch::async, threadFunc);
  
  auto t1 = thread(futureFunc, f);
  auto t2 = thread(futureFunc, f); 
  
  t1.join();
  t2.join();
  ```

  
