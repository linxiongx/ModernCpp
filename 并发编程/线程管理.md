<h1 align = "center">线程管理</h1>

## 一、线程的管理

+ #### 线程会在 std::thread 对象创建时立即启动

+ #### 启动线程后，必须在 std::thread 对象销毁之前决定等待线程( join )或分离线程( detach )，否则程序会被终止( std::thread 的析构函数会调用 std::terminate() ) 

+ #### 调用 join() 会清理线程相关的内存，这样 std::thread 对象将不再与已经完成的线程有任何关联。这意味着，只能对一个线程使用一次 join()。

+ #### 即使有异常发生，也必须确保正确的等待线程( join )或分离线程( detach )，否则程序会被终止

  ```c++
  	std::thread myThread(do_some_work);
  
  	try
  	{
  		//可能发生异常
  	}
  	catch (...)
  	{
  		if (异常已经处理，不再抛出异常)
  		{
  
  		}
  		else if (异常没有处理，继续抛出异常)
  		{
  			myThread.join(); 
  			throw; // 在继续抛出异常之前必须join线程，否则线程析构函数被调用、程序被终止！
  		}
  	}
  	myThread.join();
  ```

  

## 二、向线程传递参数

+ #### 线程传递参数的过程

  #####  1. 构造阶段：std::thread 的构造函数通过拷贝存储参数

  #####  2. 线程启动阶段：新线程开始执行

  #####  3. 参数传递阶段：std::thread 存储的参数被传递给目标函数

  #####  4. 类型转换阶段：如果需要，参数会进行隐私类型转换以匹配目标函数

  ```c++
  void f(int i,std::string const& s); 
  void oops(int some_param) 
  {
     char buffer[1024];
     sprintf(buffer, "%i",some_param); 
     std::thread t(f,3,buffer);  // 危险！改为: std::thread t(f, 3, std::string(buffer));
     t.detach();
  }
  // oops 可能会在 buffer(cosnt char*) 转换为 std::string 之前结束，新线程访问该内存从而导致未定义的行为。
  ```

  

+ #### 向线程传递的参数都会被拷贝至新线程的内存空间中; 线程构造函数无视目标函数的参数类型，盲目地拷贝已提供的变量。

+ #### std::thread 把所有参数都拷贝，想要引用，必须用 std::ref。<font color='gray'>~（"想要引用"是指目标函数的参数是引用形式）~</font>

  ```c++
  void updateData(widget_data& data);
  void oops()
  {
      widget_data data;
      std::thread t(updateData, data); // error! 改为：std::thread t(updateData, std::ref(data));
      t.join();
  }
  ```

  

+ ##### 使用成员函数作为线程函数

  ```c++
  class X
  {
  public:
  	void doWork(int nValue);
  };
  X myX;
  std::thread t(&X::doWork, &myX, 100); // 第一个参数是成员函数地址，第二个参数是 this 指针，第三个参数是成员函数的参数...
  ```

  

## 三、转移线程所有权

####          std::thread 具有只移属性，只可以移动不可以复制	

```c++
void func();
std::thread t1(func);
std::thread t2 = std::move(t1);
t1 = std::thread(func); // 右值，调用的是移动赋值函数
std::thread t3;
t3 = std::move(t2);
t1 = std::move(t3); // error, 程序崩溃！将t3所有权转移给t1，但t1已有关联的线程，系统调用 std::terminate() 终止进程

//线程可以作为函数的返回对象
std::thread f()
{
    return std::thread(some_function);
}
```



## 四、线程数量

####     std::thread::hardware_concurrency() 返回并发线程的数量(即CPU核芯数)
