<h1 align = "center">多线程同步机制</h1>

## 1. 条件竞争

+ #### 条件竞争通常是时间敏感的，所以程序以调试模式运行时，错误通常会完全消失，因为调试模式会影响程序的执行时间

+ #### 避免恶性条件竞争

  + ##### 使用锁机制

  + ##### 使用无锁编程

    

## 2. 锁机制

+ ### 锁粒度   

  ##### 让锁的粒度尽可能的小；

  

+  ### 互斥量

   ##### std::mutex、std::mutex::lock()、std::mutex::unlock()；非 RAII，需要手动加锁解锁；

   ##### 切勿将受保护数据的指针或引用传递到互斥锁作用域之外

   ##### M & M 原则：std::mutex 一般会使用 mutable 修饰

   ```c++
   class Test
   {
   public:
       void setValue(int nValue)
       {
           std::lock_guard lck(m_mtx);
           m_nValue = nValue;
       }
   
       int getValue() const
       {
           std::lock_guard lck(m_mtx); //因为 std::lock_guard 需要对 std::mutex 进行修改，如果不使用 mutable，会编译失败
           return m_nValue;
       }
   private:
       int m_nValue = 10;
       mutable std::mutex m_mtx;
   };
   ```

   

+  ### std::lock_guard

   ##### 相较于直接使用 std::mutex 的成员，std::lock_guard 是 RAII 的。

   ```c++
   mutable std::mutex mtx;
   std::lock_guard<std::mutex> locker(mtx); //构造时加锁，析构时解锁
   ```

   

+  ### std::unique_lock

   ##### 相较于 std::lock_guard，std::unique_lock 更灵活，可以手动加锁解锁。

   ```c++
   mutable std::mutex mtx;
   //std::unqie_lock<std::mutex> locker(mtx); //构造时加锁
   std::unqie_lock<std::mutex> locker(mtx, std::defer_lock); //构造时不加锁
   locker.lock(); //手动加锁
   locker.unlock(); //手动解锁
   ```

   

+  ### 读写锁

   ##### 写锁：独占所有权  ~(当一个线程占有一个写锁时，其它线程无法获取读锁，也无法获取写锁)~

   ##### 读锁：共享访问权  ~(当一个线程占有一个读锁时，其它线程可以获取读锁，无法获取写锁)~

   ```c++
   mutable std::shared_mutex mtx;
   std::lock_guard<std::shared_mutex> readLock(mtx); //读锁
   std::unqie_lock<std::shared_mutex> readLock(mtx); //读锁
   std::shared_lock<std::shared_mutex> writeLock(mtx); //写锁
   ```

   

+  ### 嵌套锁

   +  ##### 当 std::mutex、std::shared_mutex 已经上锁时，如果对其再次上锁，就会产生未定义行为。

   +  ##### 可以 对 std::recursive_mutex 进行多次上锁，只有在解锁与锁定次数相匹配时，互斥量才会被真正释放。 

      ```c++
      std::recursive_mutex mtx;
      void recursive_function(int count)
      {
      	mtx.lock(); //递归加锁
          if(count > 0)
          {
              recursive_function(count-1); //递归调用
          }
          mutex.unlock(); //递归解锁
      }
      ```

      

+  ### 自旋锁

   +  ##### 适用场景：临界区很短、低竞争<font color='gray'>~(大部分时间能立即获得锁)~</font>
   
   +  ##### 不适用场景: 长临界区、高竞争、会有优先级倒置风险
   
   ```c++
   class SpinLock
   {
   private:
   	std::atomic<bool> locked(false);
   public:
   	void lock()
       {
        //加锁逻辑分解
           //情况1：锁空闲时
           //锁当前状态：locked = false
           //执行 exchange(true) 后：
           //锁变成：locked = true（锁被占用）
           //返回值：false（之前是空闲的）
           //while(false) → 条件为假，跳出循环，获锁成功
   
           //情况2：锁被占用时
           //锁当前状态：locked = true
           //执行 exchange(true) 后：
           //锁还是：locked = true（还是被占用）
           //返回值：true（之前就被占用）
           //while(true) → 条件为真，继续循环，继续等待
               
           while(locked.exchange(true, std::memory_order_acquire))
           {}
       }
       void unlock()
       {
           locked.store(false, std::memory_order_release);
       }
   }
   ```
   
   

## 3. 死锁

+ ##### 定义:  死锁是指在多个线程(进程)执行过程中，因争夺资源而造成的一种互相等待的现象。

+ #### 如何避免死锁

  + #### 如果线程拥有一个锁时，就别去获取第二个锁
  
  +  #### 使用 std::scoped_lock 同时获取多个锁
  
  
  +  #### 让两个互斥量以相同的顺序上锁
  
  +  #### 避免在持有锁期间调用外部代码
  
     

## 4. 保护共享数据的初始化过程

+ ##### 延迟初始化：推迟对象的创建或初始化，直到第一次真正需要使用时才初始化

```c++
//单例模式 - 双重检查模式 (线程不安全)
Singleton* m_pInstance = nullptr;
Singleton* Singleton::getInstance()
{
    if(m_pInstance == nullptr) //①
    {
        std::lock_guard<std::mutex> lk(mtx);
        if(m_pInstance == nullptr)
        {
            m_pInstance = new Singleton; // ②
        }
    }
    return m_pInstance;
}
// 不是线程安全的！①和②存在数据竞争！
```

```c++
//单例模式 - 静态局部变量 （线程安全）
Singleton Singleton::getInstance()
{
    static Singleton _instance;
    return _instance;
}
// 是线程安全的！ C++ 新标准规定静态局部变量的初始化是线程安全的
```

```c++
//单例模式 - std::call_once (线程安全)
static std::once_flag Singleton::initialized;

static Singleton* Singleton::getInstance() 
{
   std::call_once(initialized, []() {
       m_pInstance = new Singleton();
   });
   return m_pInstance;
}
```



## 5. 无锁编程

