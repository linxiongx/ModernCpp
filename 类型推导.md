<h1 align = "center">类型推导</h1>

# 一、模版推导

```c++
//函数模版：
template<typename T>
void f(ParamType param);
```



- ## 情况1：ParamType  是个指针或引用

  ```c++
  template<typename T>
  void f(T& param);
  ```

  - #### 若 expr 具有引用型别，则先忽略引用

  - #### 然后，对expr的型别进行推导，来决定T的型别

  - #### 将 T 的型别替换回 ParamType，决定最终型别

    ##### 注：cv 限定符需要保留

    ##### 注：只关注值类型，不关注值类别
    
    ```c++
    //示例代码
    int  x = 27; // x 的型别是 int
    const int cx = x; // cx 的型别是 const int
    const int& rx =x; // rx 的型别是 const int&
    //调用
    f(x); // T 的型别是 int, param 的型别是 int&
    f(cx); // T 的型别是 const int, param 的型别是 const int&
    f(rx); // T 的型别是 const int, param 的型别是 const int&
    f(27); // 27的值类型是int，值类别是右值。T 的型别是 int, param 的型别是 int&   //推导成功，编译错误！无法将左值引用绑定到右值上
    ```

  

- ## 情况2：ParamType 是个万能引用

    ```c++
    template<typename T>
    void f(T&& param);
    f(expr);
    ```

    - #### 若 expr 的值类别是左值 ，则被推导为左值引用

    - #### 若 expr 的值类别是 右值，则被推导为右值引用

      ##### 注：cv 限定符需要保留

      ##### 注：关注值类别
      
      ```c++
      //示例代码
      int  x = 27; // x 的型别是 int
      const int cx = x; // cx 的型别是 const int
      const int& rx =x; // rx 的型别是 const int&
      //调用
      f(x); // T 的型别是 int, param 的型别是 int&
      f(cx); // T 的型别是 const int, param 的型别是 const int&
      f(rx); // T 的型别是 const int, param 的型别是 const int&
      f(27); // 27 是个右值，param 的型别是 int&&
      ```
      
      

- ## 情况3： ParamType 既不是指针也不是引用，是个值

  ```c++
  template<typename T>
  void f(T param);
  f(expr);
  ```
  
  - #### 若 expr 具有引用型别 ，则忽略引用
  
  - #### 若 expr 具有cv限定符，则忽略cv限定符
  
    ##### 注：只关注值类型，不关注值类别
  
    ```c++
    //示例代码
    int  x = 27; // x 的型别是 int
    const int cx = x; // cx 的型别是 const int
    const int& rx =x; // rx 的型别是 const int&
    //调用
    f(x); // T 的型别是 int, param 的型别是 int
    f(cx); // T 的型别是 const int, param 的型别是 int
    f(rx); // T 的型别是 const int, param 的型别是 int
    f(27); // 27 是个右值，param 的型别是 int
    ```

	

	## <font color='red'>总结：</font>
	
	###  	<font color='red'>  	ParamType  是个引用时，推导结果是引用</font>
	
	###  	<font color='red'> 	 ParamTyep  是个值时，推导结果是非引用</font>
	
	###  	<font color='red'> 	ParamType  是个万能引用时，根据 expr 值类别，推导结果是引用或右值引用</font>


# 二、auto 类型推导

 ###                            	auto 相当于模版推导中的  T :

+ ### auto   =>  T


+ ### auto&   =>   T&


+ ### auto&&   =>   T&&

+ #### 特别地初始化列表会被推导为：std::initializer_list< T>  <font color='gray'>~（模板推导不支持初始化列表）~</font>


```c++
	int x = 10;
	const int cx = 20;
	int& ref_x = x;
	const int& const_ref_x = x;
```

```c++
    auto a1 = x; //int
    auto a2 = cx; //int
    auto a3 = ref_x; //int
    auto a4 = 100; //int
```

```c++
    auto& r1 = x; //int&
    auto& r2 = cx; // const int&
    auto& r3 = ref_x; // int&
    auto& r4 = const_ref_x; // const int&
    // auto& r5 = 100; 非const的左值引用不能绑定到右值！
```

```c++
    auto&& rr1 = x; // int&
    auto&& rr2 = cx; // const int&
    auto&& rr3 = ref_x; // int&
    auto&& rr4 = 100; // int&& 
    auto&& rr5 = getValue(); // int&&
```

```c++
    auto x = { 1, 2, 3 }; // std::initializer_list<int>
```

