<h1 align='center'>  右值引用、移动语义、完美转发 </h1>



## 1. 形参总是左值，即使其型别是右值引用

```c++
// 右值引用作为参数不能说明资源一定会被移动，而是为了限制函数只接收右值参数，体现了"这个函数可能会消耗/移走传入的对象"这一含义。
auto func = [](string&& rValue)
{
    //rValue 的类型是右值引用，rValue 的值类别是左值
  	string str1(rValue); // rValue 是左值，不会触发移动构造函数
  	cout << rValue << endl; // 输出："ssss";
  	string str2(std::move(rValue)); //将左值转换为右值引用，触发移动构造函数
  	cout << rValue << endl; // 输出："";
};

string str = "ssss";
func(std::move(str));
```



## 2. 如果想要对某个对象执行移动操作，则不要将其声明为常量

 ####                 因为针对常量对象执行的移动操作将会一声不响的变为复制操作

```c++
class Test {
public:
    // 常量右值引用(const&&)不可以绑定到非常量右值引用(&&)
   Test(Test&& other) : value(other.value) {
       std::cout << "移动构造: " << value << std::endl;
   }
   
   // 常量右值引用(const &&)可以绑定到常量左值引用(const&)
   Test(const Test& other) : value(other.value) {
       std::cout << "拷贝构造: " << value << std::endl;
   }
   
private:
   int value;
};

int main() {
   Test obj1(42);
   const Test obj2(100);
   
   Test a = std::move(obj1);  // Test&& -> 移动构造 
   Test b = std::move(obj2);  // const Test&& -> 拷贝构造 
   
   return 0;
}
```



## 3. 区分万能引用和右值引用

+ #### 形参是 T&& 型别，且 T 参与推导则是万能引用，否则为右值引用

+ #### auto&& 是万能引用

+ #### 右值引用只能绑定到右值，万能引用即可以绑定到右值也可以绑定到左值



## 4. std::move 和 std::forward

#### 				std::move 无条件执行型别转换, 转换为右值引用

#### 				std::forward 配合万能引用使用，实参是左值则转为左值引用，实参是右值则转为右值引用。

#### 	对右值引用使用 std::move, 对万能引用使用 std::forward

